<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Project Technical Design Guidelines - Eng. Documentation</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <link href="../../css/extra.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../..">Eng. Documentation</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../..">Index</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Conventions <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../Conventions/api-convention/">API Design Conventions</a>
</li>
                                    
<li >
    <a href="../../Conventions/coding-convention/">C# Coding Conventions</a>
</li>
                                    
<li >
    <a href="../../Conventions/docker-and-k8s-conventions/">Docker and Kubernetes Conventions</a>
</li>
                                    
<li >
    <a href="../../Conventions/examples-constructor/">Constructor Parameter Examples</a>
</li>
                                    
<li >
    <a href="../../Conventions/examples-readonly-property/">Readonly Property</a>
</li>
                                    
<li >
    <a href="../../Conventions/naming-convention/">Naming Conventions</a>
</li>
                                    
<li >
    <a href="../../Conventions/python-coding-conventions/">Python Coding Conventions</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Misc <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../Misc/configure-workstation-aks/">Steps to Configure Workstation for Azure Kubernetes (AKS)</a>
</li>
                                    
<li >
    <a href="../../Misc/distributed-architecture-strategy/">Distributed Architecture Strategy</a>
</li>
                                    
<li >
    <a href="../../Misc/kubernetes-deployment-guidelines/">Kubernetes Deployment Guidelines</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Projects <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../database-and-schema-design-guidelines/">Database and Schema Design Guidelines</a>
</li>
                                    
<li >
    <a href="../product-lifecycle-requirements/">Product Lifecycle Requirements</a>
</li>
                                    
<li class="active">
    <a href="./">Project Technical Design Guidelines</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../product-lifecycle-requirements/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="disabled">
                                <a rel="prev" >
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#project-technical-design-guidelines">Project Technical Design Guidelines</a></li>
            <li><a href="#automated-testing-summary">Automated Testing - Summary</a></li>
            <li><a href="#ci-and-cd-summary">CI and CD - Summary</a></li>
            <li><a href="#monitoring-summary">Monitoring - Summary</a></li>
            <li><a href="#logging-summary">Logging - Summary</a></li>
            <li><a href="#patterns-and-practice-summary">Patterns and Practice - Summary</a></li>
            <li><a href="#infrastructure-summary">Infrastructure - Summary</a></li>
            <li><a href="#documentation-and-design-summary">Documentation and Design - Summary</a></li>
            <li><a href="#-">---</a></li>
        <li class="main "><a href="#automated-testing">Automated Testing</a></li>
            <li><a href="#plan-for-testing">Plan for Testing</a></li>
            <li><a href="#testable-designs-and-testable-code">Testable Designs and Testable Code</a></li>
            <li><a href="#fixing-untestable-code">Fixing Untestable Code</a></li>
            <li><a href="#testing-public-endpoints-and-critical-paths">Testing Public Endpoints and Critical Paths</a></li>
            <li><a href="#avoiding-tautological-tests">Avoiding Tautological Tests</a></li>
            <li><a href="#avoiding-redundant-tests-against-third-party-or-framework-code">Avoiding Redundant Tests Against Third-party or Framework Code</a></li>
            <li><a href="#business-coverage-vs-code-coverage">Business Coverage vs. Code Coverage</a></li>
            <li><a href="#testing-deployments">Testing Deployments</a></li>
        <li class="main "><a href="#ci-and-cd">CI and CD</a></li>
            <li><a href="#granular-modules-integrate-easily">Granular Modules Integrate Easily</a></li>
            <li><a href="#feature-flags">Feature Flags</a></li>
            <li><a href="#reproducible-and-deterministic-builds">Reproducible and Deterministic Builds</a></li>
            <li><a href="#using-continuous-integration-as-a-quality-measure">Using Continuous Integration as a Quality Measure</a></li>
            <li><a href="#reproducible-deterministic-idempotent-deployments">Reproducible, Deterministic, Idempotent Deployments</a></li>
            <li><a href="#faster-pipelines-equals-more-productivity">Faster Pipelines Equals More Productivity</a></li>
        <li class="main "><a href="#monitoring">Monitoring</a></li>
            <li><a href="#measure-all-mathematically-significant-metrics">Measure all Mathematically Significant Metrics</a></li>
            <li><a href="#abstracting-metric-collection-and-dispatch">Abstracting Metric Collection and Dispatch</a></li>
            <li><a href="#taking-full-advantage-of-time-series-data">Taking Full Advantage of Time Series Data</a></li>
            <li><a href="#establishing-and-maintaining-slas-on-metrics">Establishing and Maintaining SLAs on Metrics</a></li>
            <li><a href="#alerting-meaningfully">Alerting Meaningfully</a></li>
            <li><a href="#dashboards-and-stoplights">Dashboards and Stoplights</a></li>
        <li class="main "><a href="#logging">Logging</a></li>
            <li><a href="#log-almost-everything">Log (Almost) Everything</a></li>
            <li><a href="#minimize-application-logging-code">Minimize Application Logging Code</a></li>
            <li><a href="#actionable-log-data">Actionable Log Data</a></li>
            <li><a href="#meaningful-log-levels">Meaningful Log Levels</a></li>
            <li><a href="#searchable-logs">Searchable Logs</a></li>
            <li><a href="#logs-are-not-metrics-metrics-are-not-logs">Logs Are Not Metrics, Metrics Are Not Logs</a></li>
        <li class="main "><a href="#patterns-and-practice">Patterns and Practice</a></li>
        <li class="main "><a href="#infrastructure">Infrastructure</a></li>
        <li class="main "><a href="#documentation-and-design">Documentation and Design</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="project-technical-design-guidelines">Project Technical Design Guidelines</h1>
<p>It&rsquo;s one thing for us to say that we need to be writing tests, implementing proper logging and monitoring, adhering to agile and DevOps, and so on. It&rsquo;s another entirely to actually <em>do</em> those things, or more precisely, to do them for every project consistently. To help us be consistent and follow through on our goal of writing more resilient, long-lasting software, this document provides a set of guidelines.</p>
<p>These items are essential for new development, but they&rsquo;re also important for non-trivial efforts against existing products. Any design submission that does not meet these guidelines will be rejected—though don&rsquo;t let that discourage you. This is a cooperative process, and not a set of laws or rules.</p>
<p>The guidelines fall into these categories:</p>
<ul>
<li><a href="#automated-testing">Automated Testing</a></li>
<li><a href="#ci-and-cd">CI and CD</a></li>
<li><a href="#monitoring">Monitoring</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#patterns-and-practice">Patterns and Practice</a></li>
<li><a href="#infrastructure">Infrastructure</a></li>
<li><a href="#documentation-and-design">Documentation and Design</a></li>
</ul>
<p>Not every project will be compatible with every guideline, and <em>no set of guidelines can tell you how to optimally write software</em>. It&rsquo;s best to treat this as a sort of checklist you run through during the design phase of each project. To facilitate that, we&rsquo;ll begin with a series of summaries you can check off as you validate them. More in-depth discussion about each point is linked on each list item.</p>
<!-- This nasty inline javascript is only going to work on the mkdocs-compiled site, but that's OK. -->

<!-- It will look nasty on Azure DevOps but most other realtime renderers can at least render the buttons fine. -->

<p><button onclick="let inputs = document.getElementsByTagName('input'); for (let i in inputs) { if (inputs[i].type == 'checkbox') inputs[i].removeAttribute('disabled'); };">Enable Checkboxes</button> &nbsp;
<button onclick="let inputs = document.getElementsByTagName('input'); for (let i in inputs) { if (inputs[i].type == 'checkbox') { inputs[i].setAttribute('disabled', ''); inputs[i].checked = false; } };">Clear &amp; Disable Checkboxes</button></p>
<h2 id="automated-testing-summary">Automated Testing - Summary</h2>
<ul class="checklist">
<li><input type="checkbox" disabled> <a href="#plan-for-testing">Plan for testing from the very beginning (rule of thumb: 20% extra time)</a></li>
<li><input type="checkbox" disabled> <a href="#testable-designs-and-testable-code">Design testable solutions and write testable code</a></li>
<li><input type="checkbox" disabled> <a href="#fixing-untestable-code">Fix &ldquo;untestable&rdquo; code, or denote why you can&rsquo;t</a></li>
<li><input type="checkbox" disabled> <a href="#testing-public-endpoints-and-critical-paths">Test all public endpoints and critical paths</a></li>
<li><input type="checkbox" disabled> <a href="#avoiding-tautological-tests">Avoid tautological tests</a></li>
<li><input type="checkbox" disabled> <a href="#avoiding-redundant-tests-against-third-party-or-framework-code">Avoid testing third-party or framework code, but test your integrations</a></li>
<li><input type="checkbox" disabled> <a href="#business-coverage-vs-code-coverage">Shoot not for code coverage percentages but for 100% business coverage</a></li>
<li><input type="checkbox" disabled> <a href="#testing-deployments">Test your code and infrastructure deployments</a></li>
</ul>
<h2 id="ci-and-cd-summary">CI and CD - Summary</h2>
<ul class="checklist">
<li><input type="checkbox" disabled> <a href="#granular-modules-integrate-easily">Keep modules granular so they can be integrated as painlessly as possible</a></li>
<li><input type="checkbox" disabled> <a href="#feature-flags">Use feature flags where possible to release more frequently</a></li>
<li><input type="checkbox" disabled> <a href="#reproducible-and-deterministic-builds">Create reproducible and deterministic builds</a></li>
<li><input type="checkbox" disabled> <a href="#using-continuous-integration-as-a-quality-measure">Use CI process as a sign off on code quality and integration</a></li>
<li><input type="checkbox" disabled> <a href="#reproducible-deterministic-idempotent-deployments">Create reproducible, deterministic, and idempotent deployments</a></li>
<li><input type="checkbox" disabled> <a href="#faster-pipelines-equals-more-productivity">Ensure the entire pipeline takes less than 10 minutes to execute</a></li>
</ul>
<h2 id="monitoring-summary">Monitoring - Summary</h2>
<ul class="checklist">
<li><input type="checkbox" disabled> <a href="#measure-all-mathematically-significant-metrics">Measure all mathematically significant metrics</a></li>
<li><input type="checkbox" disabled> <a href="#abstracting-metric-collection-and-dispatch">Abstract as much monitoring logic out of your application as possible</a></li>
<li><input type="checkbox" disabled> <a href="#taking-full-advantage-of-time-series-data">Take full advantage of time series data</a></li>
<li><input type="checkbox" disabled> <a href="#establishing-and-maintaining-slas-on-metrics">Establish and maintain SLAs on throughput and performance</a></li>
<li><input type="checkbox" disabled> <a href="#alerting-meaningfully">Alert meaningfully</a></li>
<li><input type="checkbox" disabled> <a href="#dashboards-and-stoplights">Create dashboards and stoplights to help identify problems before they become a problem</a></li>
</ul>
<h2 id="logging-summary">Logging - Summary</h2>
<ul class="checklist">
<li><input type="checkbox" disabled> <a href="#log-almost-everything">Log (almost) everything</a></li>
<li><input type="checkbox" disabled> <a href="#minimize-application-logging-code">Put as little logging code within your application as possible</a></li>
<li><input type="checkbox" disabled> <a href="#actionable-log-data">Provide enough information in logs for them to be immediately actionable</a></li>
<li><input type="checkbox" disabled> <a href="#meaningful-log-levels">Rely on log levels, but ensure they&rsquo;re meaningful</a></li>
<li><input type="checkbox" disabled> <a href="#searchable-logs">Carefully craft logs to be eminently searchable</a></li>
<li><input type="checkbox" disabled> <a href="#logs-are-not-metrics-metrics-are-not-logs">Remember that logs are not metrics, and metrics are not logs</a></li>
</ul>
<h2 id="patterns-and-practice-summary">Patterns and Practice - Summary</h2>
<ul class="checklist">
<li><input type="checkbox" disabled> Apply SOLID principles, but don&rsquo;t be dogmatic</li>
<li><input type="checkbox" disabled> Be monolithic when you need to be; be modular when it matters</li>
<li><input type="checkbox" disabled> Consume services responsibly; provide responsible services</li>
<li><input type="checkbox" disabled> Be creative where needed and formulaic to save time</li>
<li><input type="checkbox" disabled> YAGNI</li>
<li><input type="checkbox" disabled> Get WET before you worry about being DRY</li>
<li><input type="checkbox" disabled> Expose configuration externally to minimize the need for recompilation and redeployment</li>
<li><input type="checkbox" disabled> Avoid technical debt, and plan immediately to pay any you accrue off</li>
</ul>
<h2 id="infrastructure-summary">Infrastructure - Summary</h2>
<ul class="checklist">
<li><input type="checkbox" disabled> Express infrastructure requirements as code</li>
<li><input type="checkbox" disabled> Make your application highly available, load balanced, fault tolerant, and scalable</li>
<li><input type="checkbox" disabled> Consume resources responsibly</li>
<li><input type="checkbox" disabled> Store secrets securely</li>
<li><input type="checkbox" disabled> Have a back-out strategy for bad/failed deployments</li>
<li><input type="checkbox" disabled> Plan for emergency deployment of critical services—or document the lack of plan/capability</li>
</ul>
<h2 id="documentation-and-design-summary">Documentation and Design - Summary</h2>
<ul class="checklist">
<li><input type="checkbox" disabled> Create a design document that demonstrates how requirements will be satisfied</li>
<li><input type="checkbox" disabled> Address many of the same concerns as this document in your design doc</li>
<li><input type="checkbox" disabled> Record the intangibles for future reference to avoid tribal knowledge</li>
<li><input type="checkbox" disabled> Keep design, requirements, and other project docs centralized and grouped together</li>
<li><input type="checkbox" disabled> Treat API documentation as a first-class deliverable</li>
<li><input type="checkbox" disabled> Write self-documenting code </li>
<li><input type="checkbox" disabled> Automate doc creation and publishing</li>
</ul>
<h2 id="-">&mdash;</h2>
<h1 id="automated-testing">Automated Testing</h1>
<p>Automated testing is vital to the long-term success of any engineering effort, but it&rsquo;s especially critical for applications following an agile/DevOps methodology. Tests are how you help keep from breaking things when you move fast, and they increase confidence in deployments. The objective of releasing often isn&rsquo;t necessarily to catch bugs more quickly; it&rsquo;s to surface <em>defects</em> in general. Reducing the number of avoidable defects by eliminating easy bugs using automated testing means you can spend more time addressing the stuff that matters.</p>
<h2 id="plan-for-testing">Plan for Testing</h2>
<p>If you&rsquo;re not planning for testing, you won&rsquo;t write tests. This may sound obvious, but too many teams assume that testing is just part of development. Their estimates are usually inaccurate, and they spend time that otherwise could have been spent on tests just finishing the work instead.</p>
<p>A good rule of thumb is to add 20% extra time to estimates for testing (and testing alone). Go through your team&rsquo;s usual methodology for estimation. Whether it&rsquo;s hours, days, story points, or whatever—create your estimate as usual. Then, add 20% to that. This is not <em>padding</em> or <em>fluff</em>. This is the bare minimum time you can expect to spend on writing tests. If you expect that a task or project will require additional test-writing time, you are empowered to add more than just 20%.</p>
<table>
<thead>
<tr>
<th>Avoid Influencing Estimates with Testing Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>Be careful not to start adding time for testing until you&rsquo;ve settled on the estimate for the work. You want to avoid subconsciously influencing your estimate by the amount of testing time it would add. It is more important to estimate accurately and write good code (which means good tests) than it is to give management a lower number.</td>
</tr>
</tbody>
</table>
<h2 id="testable-designs-and-testable-code">Testable Designs and Testable Code</h2>
<p>This document cannot teach you how to design testable solutions, nor how to write testable code. These topics alone are worthy of entire books. What it can do is help explain what makes a solution or module testable, and then encourage you to learn and ask questions.</p>
<h3 id="testable-design-is-usually-modular-design">Testable Design is Usually Modular Design</h3>
<p>Past a certain point of trivial simplicity, monolithic designs tend to be harder to test. </p>
<ul>
<li>Even if every code unit that makes up the system is perfectly testable (a goal which, itself, is more challenging in monolithic designs), the system as a whole is often not. <ul>
<li>It&rsquo;s only as good as the aggregate of its unit tests. </li>
</ul>
</li>
<li>Failures in a single module cause the entire system to be rejected, which drastically increases the impact of regressions. </li>
<li>Monolithic code modules are, by definition, more complex. Complexity increases the likelihood of defects.</li>
</ul>
<p>By contrast, modular designs tend to be simpler (per module), which reduces the likelihood of defects. They also isolate impacts to single modules, meaning other fixes, features, and improvements are not held back by the one defective module.</p>
<p>&ldquo;Modular&rdquo; doesn&rsquo;t have to mean microservices. Often it will, but modularity can be achieved through several mechanisms: packages, libraries, sidecar services, and more. So long as a given module can be <strong>written</strong>, <strong>deployed</strong>, <strong>referenced</strong>, and <strong>maintained</strong> independently of other modules, modularity has been achieved. Don&rsquo;t take this to mean your modules can&rsquo;t take dependencies. They can, so long as those dependencies are themselves modular. Modularity is a &ldquo;turtles all the way down&rdquo; sort of thing.</p>
<h3 id="testable-code-is-always-solid-code">Testable Code is Always SOLID Code</h3>
<p>It is possible at the <em>system</em> level to design something testable without relying on modularity, especially when the system is trivial or itself a module. However, when it comes to testing <em>code units</em>, there is less flexibility. Without following <a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> principles fairly closely, it is inevitable that the code will become test-resistant. It may occur immediately or it might degrade over years of maintenance, but it will happen. </p>
<p>Using a principled approach throughout the software&rsquo;s lifecycle, even during maintenance mode, will help stave off technical debt, omniscient dependencies, and even entropy. Sometimes, an application may seem so trivial or straightforward that &ldquo;going through the motions&rdquo; isn&rsquo;t worth it. But, <em>it is</em>, and to view these principles as rote practice is to miss the point (as we&rsquo;ll discuss more later in this document).</p>
<p>It&rsquo;s always significantly faster to do it right in the beginning than to come back and re-do it later. The nature of software is to grow and morph over time. Unless you&rsquo;re 100% sure that you&rsquo;re writing a dead-end application that will never evolve, be copy/pasted from, referred to by future developers, or be called upon to suddenly scale, it&rsquo;s worth it.</p>
<h3 id="example-of-testable-vs-test-resistant-code">Example of Testable vs. Test-resistant Code</h3>
<p>We&rsquo;ve talked a lot about what makes something <em>testable</em>, but how can you tell the difference? Here&rsquo;s an example of the contrast between <em>testable</em> and <em>test-resistant</em> code. Don&rsquo;t focus too much on the underlying language (C#) or patterns&ndash;those are only used to give context to the examples&ndash;just focus on how you&rsquo;d write tests for this logic.</p>
<pre><code class="csharp">/* Test-resistant Example */

/* 
Modules:
    SalesReportWebsite
*/

// ------
// Sales.cs
// ------
// Assume SalesData is a POCO and that the referenced fields exist on it
public class Sales
{
    public SalesData GetSalesData()
    {
        var sales = /* Pretend this does something, like query a database or read a file */;
        return sales;
    }
    public decimal CalculateSalesFromOnline(SalesData sales)
    {
        return sales.Daily.Where(s =&gt; s.Source == &quot;Online&quot;).Select(s =&gt; s.Dollars).Sum();
    }
}

// ------
// SalesController.cs
// ------
// Pretend this is a really simple ASP.NET MVC Controller
public class SalesController : Controller
{
    public SalesController() { }

    public Sales SalesLogic { get; } = new Sales();

    /* ...other methods/actions... */

    public string ReportOnlineSales()
    {
        var sales = SalesLogic.GetSalesData();
        var salesFromOnline = SalesLogic.CalculateSalesFromOnline(sales);
        return $&quot;Sales from Online sources were ${salesFromOnline}.&quot;;
    }
}
</code></pre>

<pre><code class="csharp">/* Testable Example */

/*
Modules:
    SalesContracts    
    AcmeSalesReports - depends on SalesContracts
    SalesReportWebsite - depends on SalesContracts, AcmeSalesReports
*/

// ------
// ISalesQuery.cs - in SalesContracts.csproj
// ------
// Assume SalesData is a POCO
public interface ISalesQuery
{
    SalesData GetSalesData();
}

// ------
// ISalesCalculator.cs - in SalesContracts.csproj
// ------
public interface ISalesCalculator
{
    decimal CalculateSalesFromOnline(SalesData sales);
}

// ------
// SalesController.cs - in SalesReportWebsite.csproj
// ------
// Pretend this is a really simple ASP.NET MVC-style Controller
public class SalesController : Controller
{
    public ISalesQuery SalesQuery { get; }
    public ISalesCalculator SalesCalc { get; }

    public SalesController(ISalesQuery salesQuery, ISalesCalculator salesCalc) 
    { 
        SalesQuery = salesQuery;
        SalesCalc = salesCalc;
    }   

    /* ...other methods/actions... */

    public string ReportOnlineSales()
    {
        var sales = SalesQuery.GetSalesData();
        var salesFromOnline = SalesCalc.CalculateSalesFromOnline(sales);
        return $&quot;Sales from Online sources were ${salesFromOnline}.&quot;;
    }
}

// ------
// Startup.cs - in SalesReportWebsite.csproj
// ------
// Pretend this is an application of the ASP.NET Core startup pattern
public class Startup
{
    /* ...ASP.NET Core boilerplate goes here... */

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();

        // The prod implementations of ISalesQuery and ISalesCalculator live in AcmeSalesReports.
        // However, they're not shown here because who cares?
        // The point is that they could be anything that adheres to the interface contract.
        services.AddTransient&lt;ISalesQuery, SomeSalesQueryImplementation&gt;();
        services.AddSingleton&lt;ISalesCalculator, SomeSalesCalculatorImplementation&gt;();
    }
}
</code></pre>

<p>The &ldquo;testable&rdquo; example is a very basic and imperfect implementation of dependency injection using the provider that comes with ASP.NET Core, but don&rsquo;t worry about that. Instead, consider how you would write tests for one vs. the other given what&rsquo;s shown here. In the first example:</p>
<ul>
<li>How would you write a test that doesn&rsquo;t <em>actually</em> connect to the database? </li>
<li>How would you test that the generated report is correct when the backing data is live and could change? </li>
<li>How could you test the generated report without breaking that test the instant a customer wants the sales calculation to change slightly? </li>
<li>How could you assert that the report is in the correct format without worrying about the correctness of the calculation, and vice versa?</li>
</ul>
<p>In the second example, the answers to the above questions are trivial.</p>
<h3 id="when-to-write-tests-during-development">When to Write Tests During Development</h3>
<p>Some engineers evangelize Test-driven Development (TDD), where tests are written before the logic. Others prefer to write tests after the fact. Both of these have flaws: TDD tends to promote over-modularized, trivial code with tautological tests, and testing after the fact often causes developers to miss obvious cases they may have otherwise remembered. Sometimes the best option is to write the test at the same time as you write the logic, but this requires greater discipline and isn&rsquo;t compatible with everyone&rsquo;s thought process.</p>
<p>Instead, get in the habit of considering what is best for you at each unit level. Applied this way, each developer can work optimally without needing to enforce a methodology. Some people work best when they write the test first, as it allows them to build a &ldquo;skeleton&rdquo; of the logic ahead of time that focuses on business rules. Others keep the testing in mind as they write a unit, and then hammer out the test quickly after. A few programmers switch back and forth between the unit and the test, adding things to each cooperatively. </p>
<p>The unit itself might dictate how tests are best written. Units with atomic outputs to assert or static algorithms to check are great candidates for test-first development. Units that require large amounts of input variation or conditional state manipulation often lend themselves well to side-by-side development with the tests. Units dealing with large schema-bound data objects or tight integrations with other services often come naturally to testing afterwards. The important part is to <strong>think about the unit before you begin writing it</strong> and decide at the time how best to write the test.</p>
<h3 id="where-to-go-from-here">Where to Go from Here</h3>
<p>If you&rsquo;re not used to writing testable code, it will take some time to adjust. Do some reading on the SOLID principles and practice applying them in code. Remember to decide how you&rsquo;re going to a test a unit before you even write it. Perhaps most importantly, if you&rsquo;re unsure whether a design or unit is testable, ask someone! It&rsquo;s usually easier to imagine the dependencies and side-effects of a method/design as someone that didn&rsquo;t write it.</p>
<h2 id="fixing-untestable-code">Fixing Untestable Code</h2>
<p>Often, you&rsquo;ll find yourself applying these guidelines to existing code instead of greenfield projects. When that happens, aside from the challenges of designing a solution, you&rsquo;ve also got to deal with whatever decisions came before. That usually involves some level of technical debt. Older code&ndash;especially stuff written before these principles became commonplace&ndash;tends to have piles of technical debt or, sometimes, just poor design. Trying to write tests against this stuff can seem impossible.</p>
<p>However, there is no such thing as &ldquo;untestable&rdquo; code. What you&rsquo;ve really got is <em>test-resistant</em> code. The difference might seem like an ideological exercise, but the important distinction is your mindset. You should be thinking about how to make the code more testable. Not all code can immediately be made testable, but that&rsquo;s not a roadblock. What steps can you take right now? How can the code begin to evolve into a testable state?</p>
<p>To be clear, the correct answer is usually not to hack tests into test-resistant units. The objective is to either make the code more testable or to begin the initiative of making it more testable. Make a plan for how to get there and execute it. The value of good tests is too high to abandon them when the task seems daunting. Each and every developer is responsible for code quality and cleanliness, and each of us is empowered to design solutions.</p>
<p>Having said that, this set of guidelines can&rsquo;t predict every scenario. It&rsquo;s possible, if you&rsquo;re time-limited and it&rsquo;s truly hideous code, there isn&rsquo;t enough time to even <em>begin</em> tackling the testability. Even in those cases, you should come up with a plan you (or someone) can pursue later, but what if you don&rsquo;t even have time to <em>plan</em>? Regardless of the reason why, if you accept that you&rsquo;re unable to write tests, you <strong>must document</strong> the reasons why. Store them with the documentation (both technical and project) so that in the future, when someone comes back to the code you wrote, you&rsquo;ll save them some time having documented the issues you ran into.</p>
<h2 id="testing-public-endpoints-and-critical-paths">Testing Public Endpoints and Critical Paths</h2>
<p>When writing tests, the most important units to cover are those directly used to satisfy public endpoints (i.e. the API of your module). These are <em>always</em> business critical, by definition. This will intentionally lead you down a rabbit hole of testing, where you start asserting all of the conditions and dependencies that lead up to the endpoint. </p>
<p>A <a href="https://dl.acm.org/doi/10.5555/371029.371037">critical path</a> is logic where your application spends the majority of its time; or, more precisely, the paths where optimization efforts are most valuable as they reduce the overall execution time for a given operation. Most of the time, following the above guidance, you will end up covering your critical paths by necessity. However, great care should still be taken to ensure they&rsquo;re well tested. Optimizations are a frequent source of regressions, and being a <em>critical</em> path implies that regression would be highly detrimental.</p>
<h2 id="avoiding-tautological-tests">Avoiding Tautological Tests</h2>
<p>A tautological test is one where the test will always pass, usually because the unit and test are essentially equivalent. A rudimentary example in Python:</p>
<pre><code class="python">def sum(a, b):
    return a + b
def myTest():
    assert(sum(3, 4) == 3 + 4)
</code></pre>

<p>Notice that the test asserts <code>sum(3, 4)</code> by comparing it to <code>3 + 4</code>. Technically, this test is validating that addition is performed correctly in the <code>sum</code> function. However, the condition is only checked by essentially replicating the unit being tested. Even if the test were improved it would still be tautological:</p>
<pre><code class="python">def sum(a, b):
    return a + b
def myTest():
    assert(sum(3, 4) == 7)
</code></pre>

<p>The test can never fail, although in this version it&rsquo;s more because the test is asserting basic language functionality, which can be assumed to not fail. The nature of the <code>sum</code> unit is the problem rather than the test itself. Here&rsquo;s an example of a non-tautological test that is similar:</p>
<pre><code class="python">def calculateGMROII(profit, avgInventoryCost):
    return profit / avgInventoryCost
def myTest():
    assert(calculateGMROII(100000, 25000) == 4)
</code></pre>

<p>This isn&rsquo;t testing that Python is capable of dividing two numbers. It tests that the GMROII calculation behaves as expected. This is a business case which provides value, and a change in the algorithm for GMROII would likely impact downstream systems. Therefore, this is a useful, non-tautological test even though the calculation is relatively simple.</p>
<h3 id="where-tautology-gets-tricky">Where Tautology Gets Tricky</h3>
<p>The examples above are trivial for the sake of demonstration. Most of the time, a test becomes tautological through less obvious means. Frequently, a test can appear perfectly valid until you &ldquo;solve&rdquo; it down like algebra. If the test solves down to (for example) <code>2x = x / 0.5</code>, you&rsquo;ve got a tautology. A more practical example:</p>
<pre><code class="python">WEEK = 201801
TESTDATA = [{'week': WEEK, 'value': 123}, {'week': WEEK, 'value': 456}, {'week': WEEK, 'value': 789}]

# This is the unit being tested
def dataSlicer(dataLoaderCallback, week, skip, take):
    data = dataLoaderCallback()
    dataAtWeek = [d for d in data if d['week'] == week]
    return dataAtWeek[skip:skip+take]

def test_dataLoader():
    return TESTDATA
def myTest():
    sliceData = dataSlicer(test_dataLoader, WEEK, 2, 1)
    assert(len(sliceData) == 1)
    assert(sliceData[0] == {'week': WEEK, 'value': 789})
</code></pre>

<p>It is left as an exercise to the reader to determine why this one is tautological, but as a hint: simplify the test down until it becomes clearer.</p>
<h2 id="avoiding-redundant-tests-against-third-party-or-framework-code">Avoiding Redundant Tests Against Third-party or Framework Code</h2>
<p>There is no value in writing a test against someone else&rsquo;s code in your test suite. For example, if there is a math library you&rsquo;re referencing, don&rsquo;t bother writing tests against its <code>pow()</code> function. If you&rsquo;re relying on an extension library to remove entities from an Entity Framework set, there&rsquo;s no need to test that the entity was actually removed.</p>
<p>A module&rsquo;s tests belong with the module. No tests in your suite should be written against other modules. If you find a test case for another module, for example a scenario that causes unexpected output, you should attempt to add it to that module&rsquo;s suite. If that&rsquo;s not possible, don&rsquo;t worry about it. Write a test for your workaround instead, such that when the module updates and works correctly again, your workaround test will break.</p>
<p>Speaking of testing code integrations, while there&rsquo;s no value in testing the third-party library, there is a ton of value in testing your units&rsquo; integration with those libraries. A great example is where your logic must transform the output from a third-party source in some way. Don&rsquo;t bother testing that the third-party source returns the output as you expect; instead, test that your transformations behave as expected against all important possible outputs (including failures).</p>
<h2 id="business-coverage-vs-code-coverage">Business Coverage vs. Code Coverage</h2>
<p>Many of the same shops that espouse TDD will enforce a 100% code coverage standard. In other words, all reachable code must be touched by a test in the suite. This dogmatic approach to testing leaves no room for interpretation or flexibility; often, builds will automatically be rejected if coverage falls below a certain percent. Speaking strictly about the dogmatism and zealotry, there is no value in code coverage-based testing standards. These shops are usually trying to substitute out high-quality engineers and smart people with rigid, rote practice, and it never<strong><a href="#code-coverage-incentives">*</a></strong> works. There is no substitute for good developers.</p>
<p>True value comes from looking at <em>business coverage</em>. Business coverage is just making sure that your suite has tests covering all of your business cases, asserting your business rules, and testing that your value-generating logic continues to work as intended. The test spec is created by strong requirements and clear, visible design. Coverage is ensured through due diligence during development and careful peer review focused not just on code quality, but on business value as well.</p>
<table>
<thead>
<tr>
<th>Difference Between Code Coverage and Business Coverage</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code coverage only validates that the code units behave as expected. Business coverage is focused on ensuring that the application performs all business-valuable operations in the correct way. They frequently intersect but the mindset behind the two is very different.</td>
</tr>
</tbody>
</table>
<p>Calculating business coverage is not as easy as using a tool to spit out a percentage and automatically failing when it falls below a threshold, but it&rsquo;s infinitely more useful as a signpost of quality. As a result of its subjectivity, there can never be a simple numeric representation. It will instead fall to discipline and practice, which is one of the reasons high-quality engineers are important. Code coverage enthusiasts assume that a 100%-covered solution will by definition ensure 100% business coverage, but this couldn&rsquo;t be further from the truth. If it completely misses valuable business cases (because the units were not written to address them), it might as well be 0% covered. </p>
<p><sub id="code-coverage-incentives">* Even when people say it works, it&rsquo;s probably not <em>actually</em> working. A team gets the results it incentivizes, so when it incentivizes code coverage, that&rsquo;s precisely what developers focus on&ndash;to the detriment of code that does anything useful.</sub></p>
<h2 id="testing-deployments">Testing Deployments</h2>
<p>Just as important as unit-level and module-level testing is deployment-level testing. Testing a deployment means validating that the build/release pipeline is successful and adheres to infrastructure and architecture requirements. As discussed in the later section on <a href="#ci-and-cd">CI/CD</a>, the pipeline should be held to several standards. Deployment testing asserts those standards. For example, a deployment test for a service might validate that it deploys idempotently.</p>
<p>Unlike other testing granularities, deployment testing requires a suitable environment. Cloud-first applications enjoy an advantage here, as infrastructure can be trivially acquired temporarily to test a pipeline and then disposed after the test. Thanks to products like Kubernetes, however, even private cloud applications can acquire and dispose of infrastructure programmatically. </p>
<p>Test results are usually binary: absolute success or complete failure. Deployment tests, however, can sometimes fail due to transient errors inherent to Infrastructure-as-a-Service (IaaS) platforms. Whether it&rsquo;s Azure, Google, or vSphere, sometimes the infrastructure just cannot be created for unknown, unimportant, and temporary reasons. Because of this, it is not recommended to automate the testing of deployments. It should be <em>scripted</em>, but the success of a pipeline should never rely on the outcome of a deployment test.</p>
<p>You may be asking, &ldquo;if the test shouldn&rsquo;t be automated, when should it be run?&rdquo; Deployment testing should be conducted before the module is promoted into a production branch (i.e. <code>master</code>). Usually, infrastructure deployments into production are gated by a DevOps engineer anyway; it falls to them to execute the provided deployment tests. If the test does not pass, the DevOps engineer will not allow the module to pass. Thankfully, DevOps engineers should be the most knowledgeable source of information about how to write a deployment test, so cooperate with them to fix your infrastructure and/or write a valid test.</p>
<h1 id="ci-and-cd">CI and CD</h1>
<p>The principles of Continuous Integration (CI) and Continuous Delivery (CD) are vital to getting the maximum value out of our projects. Developers are often unable to accomplish work as fast as possible due to roadblocks or speed bumps in the release process. CI/CD are a central part of every flavor of agile methodology because they remove roadblocks and speed bumps; developers are enabled to move quickly and deploy often. In fact, some teams/projects will even choose to use Continuous Deployment to ensure their latest code is always released when it&rsquo;s available.</p>
<p>For reference, here are some quick definitions:</p>
<ul>
<li><strong>Continuous Integration</strong>: the practice of automatically validating that new commits from many authors integrate properly with the existing code base. In other words, CI is making sure that failures or flaws were not introduced when all commits have merged together. Often, it implies frequent merges to minimize the impact of drifting changes between branches over time.</li>
<li><strong>Continuous Delivery</strong>: the practice of being able to release changes as quickly as possible. Usually, this entails having an up-to-date release artifact ready to go live at all times. While not necessary, it&rsquo;s considered healthy to release as frequently as possible; this reduces the &ldquo;blast radius&rdquo; of the changeset.</li>
<li><strong>Continuous Deployment</strong>: a corollary to CD, this is the practice of taking the up-to-date release artifact generated by the CD process and automatically releasing it as soon as it&rsquo;s generated successfully. <ul>
<li>There is some debate over whether the automatic release must be into <em>production</em>. For the purposes of this document, assume that it must at least deploy into a production staging environment which can trivially become production.</li>
</ul>
</li>
</ul>
<h2 id="granular-modules-integrate-easily">Granular Modules Integrate Easily</h2>
<p>This is a deceptively simple concept: more granular modules are easier to integrate. That statement has a dual meaning; it refers both to code integration and system integration. Module-level integration testing runs faster and, thanks to lower complexity, proves more decisive. System-level integration (i.e. deploying the module into a running environment) has a lower impact risk if the module is small. Tend toward more granular modules, where possible, to amplify these advantages—though obviously balance it against the increase in system complexity.</p>
<h2 id="feature-flags">Feature Flags</h2>
<p>A common (and healthy) practice in CD is to release changesets as frequently as possible. As mentioned above, this reduces the possible impact of any single changeset. Another benefit, however, is the ability to get features into production to harden ASAP. As the saying goes, no plan survives contact with the enemy, so why not get the plan in front of them as soon as possible?</p>
<p>Of course, not every infant feature is ready to be seen by users immediately. Even if there would be a ton of value in having developers test the feature in the production environment, users have a habit of forming an impression the first time they see a feature whether it&rsquo;s &ldquo;ready&rdquo; or not. This is where feature flags come into play. They can allow you to toggle features in real-time, gate features by user (or other logic), and expose functionality internally without making it visible to the public, among other things. You get this while also getting to integrate and test the feature where it matters: in production.</p>
<p>The implementation of feature flags is outside the scope of this document (though <a href="https://martinfowler.com/articles/feature-toggles.html">here is a decent reference</a> for more information). Getting into the habit of using them and releasing features earlier will usually result in stronger features, better testing, and smoother user acceptance. This is especially true if you&rsquo;re able to run pilot programs or A/B testing with your feature flags.</p>
<h2 id="reproducible-and-deterministic-builds">Reproducible and Deterministic Builds</h2>
<p>In order to reduce time-consuming troubleshooting on build/deploy pipeline issues, avoid unpredictable application regressions, and create higher confidence in releases, you should strive for all builds to be reproducible and deterministic.</p>
<p>A <em>reproducible</em> build means that the set of conditions (operating environment, variables, code state, etc.) required to build a product can be replicated on demand, for any (reasonable) past or current version of the product.</p>
<p>An example of a build that is <em>not</em> reproducible is one that relies on being built on machines that, externally to the pipeline, have been prepared with prerequisites. For example, if the pipeline does not install the .NET Core 3 SDK, but your build requires it, it is not reproducible. Perhaps a more volatile example: if the build relies on resources that could become permanently unavailable (say, downloading a library from someone&rsquo;s personal website), it is not reproducible.</p>
<p>A <em>deterministic</em> build is one where, given that set of reproducible conditions, the build output will be the same every time. Creating a deterministic build can sometimes be tricky. Many modern package managers or similar concepts, like Docker image repositories, allow you to take dependencies not on exact versions but instead on minor, major, or even latest versions. Doing this causes your build to become non-deterministic. Some build pipelines take dependencies on time-sensitive or context-sensitive variables; these are non-deterministic as well.</p>
<table>
<thead>
<tr>
<th>Important</th>
</tr>
</thead>
<tbody>
<tr>
<td>Most package managers support some form of <em>lock file</em> or similar mechanism that ensures your packages <em>and all their dependences</em> resolve to deterministic versions. You must take advantage of this mechanism. Too often, a package you depend on will take a loose dependency on another package. Since that indirect package could change without you changing anything in your direct dependencies, your build is no longer reproducible or deterministic. Locking the chain of dependencies resolves the issue as much as can reasonably be expected.</td>
</tr>
</tbody>
</table>
<h2 id="using-continuous-integration-as-a-quality-measure">Using Continuous Integration as a Quality Measure</h2>
<p>The more trust you can place into your CI process&rsquo;s ability to vet your changes, the more trust you can have in deploying. CI/CD is built on enhancing trust to the point of having faith a given deployment will succeed. Defects and regressions will always happen—no process can catch them all—but having confidence that the automated pipelines will take care of the obvious stuff removes a lot of anxiety.</p>
<p>This is why your CI pipelines run the automated test suites for your projects, why you merge early and often, and why you perform CI at all. It helps increase confidence in the artifacts being generated and the work being done. You should make sure your CI process is doing everything (within reason) to assert the quality of your code, changes, and artifacts. </p>
<h2 id="reproducible-deterministic-idempotent-deployments">Reproducible, Deterministic, Idempotent Deployments</h2>
<p>Much like your builds, your deployments should be reproducible and deterministic. For the most part, you can reference the <a href="#reproducible-and-deterministic-builds">section on builds</a> and apply the same principles here. There are some differences, which this section will focus on.</p>
<p>A <em>reproducible</em> deployment differs from a reproducible build only in that the environment you&rsquo;re reproducing is different. Rather than making sure the build occurs in the same environment, here you&rsquo;re ensuring that the <em>infrastructure</em> itself is reproducible. A deployment should be able to create its necessary infrastructure, dependencies, and so on. For example, if your application depends on its own RabbitMQ instance, your deployment must be able to reproduce that.</p>
<p>A reproducible deployment leads into making a <em>deterministic</em> deployment. Assuming deterministic build artifacts, the resulting deployment should be the same every time. This means that deploying your artifact fresh to the platform should result in the exact same code, infrastructure, backing services/dependencies, networking, and so on, every time. </p>
<p><em>Idempotency</em> here means that, after the first time, deploying the same artifacts again will change nothing. The existing deployment will be unaffected. Without tools that help enforce idempotency (like Kubernetes and its declarative YAML format), it can be difficult to achieve it for your pipelines. </p>
<p>Idempotency extends further to the individual components of each deployment. For example, imagine you have executed a deployment pipeline which creates a RabbitMQ instance, two services, and one load balancer in Kubernetes. Then, a minor code change to one service causes a new artifact to be created. When you execute the pipeline with this new artifact, only the changed service should be affected. If you end up with two RabbitMQ instances, four services, and two load balancers&hellip; that&rsquo;s a problem.</p>
<h2 id="faster-pipelines-equals-more-productivity">Faster Pipelines Equals More Productivity</h2>
<p>It probably goes without saying, but if your pipelines are fast, you can respond more quickly to issues. No matter how much testing we automate, how often we test deployments, or how diligent our developers are in peer review, sometimes stuff slips through the cracks. Imagine a build/release pipeline that takes 45 minutes to run. Any error, even something so trivial you can correct it in literally one second, requires a minimum of 45 minutes to fix. Imagine how long it takes when it&rsquo;s something serious or you need to release multiple times.</p>
<p>As a rule of thumb, keep CI/CD pipelines under 10 minutes of execution time. It&rsquo;s fine if they run longer when releasing to an empty environment (i.e. releasing for the first time), but given that <a href="#reproducible-deterministic-idempotent-deployments">the components should be idempotent</a>, later executions should be much quicker.</p>
<h1 id="monitoring">Monitoring</h1>
<p>Without being able to measure what&rsquo;s going on in a system, you&rsquo;re stuck taking shots in the dark when issues crop up. Even worse, you only know issues are happening once they&rsquo;ve already caused some kind of impact. In complex systems, it can take tens of minutes&ndash;sometimes hours&ndash;to find which subsystem is even having the issue before you can start debugging. It&rsquo;s especially nasty when the issue isn&rsquo;t a wholesale failure, but a transient error, throughput issue, performance problem, or similar functional-but-bad state.</p>
<p>Good monitoring is the key to solving the visibility issues that many teams face in production systems.</p>
<h2 id="measure-all-mathematically-significant-metrics">Measure all Mathematically Significant Metrics</h2>
<p>When in doubt, it&rsquo;s better to over-measure than to under-measure. You should record every metric your application deals in. Whether it&rsquo;s CPU usages, memory used/free, number of threads, time required, message throughputs, number of files processed in the current operation, or even network utilization, you should be recording it one way or another.</p>
<table>
<thead>
<tr>
<th>Mathematically Significant?</th>
</tr>
</thead>
<tbody>
<tr>
<td>A <em>mathematically significant</em> metric is a number that has meaning in comparison or contrast to other numbers, and whose value scales by some mathematical function with variables in the developer&rsquo;s control. Usually, these are obvious metrics: number of operations per second, CPU usage, count of I/O waits, and so on. The distinction is made to contrast these metrics against &ldquo;soft&rdquo; measurements like, for example, a user satisfaction rating. A user satisfaction rating is something that can be <em>measured</em>, but only using an arbitrary scale and without the ability to directly affect the outcomes.</td>
</tr>
</tbody>
</table>
<p>The objective of recording all these metrics is to be able to draw conclusions about the state and performance of the system, both the system as a whole and its subsystems. We need these insights both real-time and historically. Imagine a dashboard showing a line graph of your application&rsquo;s message throughput next to a pie chart of the breakdowns of the types of work sitting in the queue. Beside that is a bar chart showing current throughput per type vs. average throughput per type at this time. You&rsquo;d be able to quickly pinpoint potential issues in an instant, rather than having to identify that a problem exists and then run a bunch of queries or aggregate a bunch of logs to gather the metrics yourself.</p>
<p><img alt="Sample Dashboard centered" src="../images/sample-dashboard.png" /></p>
<p>Obviously, not every metric in that imaginary dashboard must necessarily come from your application, but for it to exist, all applications must be dutifully reporting metrics. When deciding what to measure, there are some bare minimum metrics that <em>every application</em> should be recording, shown here along with some examples.</p>
<ul>
<li>Utilizations<ul>
<li>CPU, RAM, disk, network, files, threads, processes, etc.</li>
</ul>
</li>
<li>Throughputs<ul>
<li>Number of messages processed, number of operations performed, number of service calls made, number of records read, etc.</li>
</ul>
</li>
<li>Workloads<ul>
<li>Number of messages waiting, number of files yet to process, count of jobs currently running, etc.</li>
</ul>
</li>
<li>Times<ul>
<li>Time required to complete an operation, time elapsed between heartbeats, time spent on reading files, time spent on waiting for a database, time spent waiting on network communication, uptime, etc.</li>
</ul>
</li>
</ul>
<p>Recording a metric, as discussed below in the <a href="#abstracting-metric-collection-and-dispatch">Abstract Metric Collection</a> section, should be trivial to your application in terms of resource cost and logic required. Some of these minimum metrics are taken care of for you automatically, depending on the application platform. For example, Kubernetes takes care of measuring most of your application&rsquo;s resource utilizations in that environment (but not necessarily all). If your application uses RabbitMQ as a message broker, it can be configured to report metrics automatically as well.</p>
<table>
<thead>
<tr>
<th>Value in Non-Mathematical Metrics</th>
</tr>
</thead>
<tbody>
<tr>
<td>Despite the focus in this section on <em>mathematically significant</em> metrics, there can certainly be value in other metrics which aren&rsquo;t as &ldquo;hard&rdquo;. However, those metrics should be measured outside the scope of your project&rsquo;s system monitoring effort. Their collection might, for example, be part of the application&rsquo;s business requirements rather than a system-level architectural necessity.</td>
</tr>
</tbody>
</table>
<p>It&rsquo;s important that you consider your monitoring carefully even when various platforms provide assistance. This guidance takes care not to prescribe any particular solutions because only you, the developer, know best what&rsquo;s appropriate for your project. Only you can know which metrics you should record that might not be provided by your infrastructure.</p>
<h2 id="abstracting-metric-collection-and-dispatch">Abstracting Metric Collection and Dispatch</h2>
<p>It may seem a little counter-intuitive to recommend measuring <em>everything</em>, then immediately say your application should do as little measuring as possible. The key phrase, however, is <strong>your application</strong>. This means that every effort should be made to collect metrics about the application outside of the app&rsquo;s logic. </p>
<p>If the logic must expose a metric (for example, because the data can only be recorded by the logic), it should do so plainly, in a way that does not take dependencies on specific mechanisms, infrastructures, or frameworks. Another process, such as a Kubernetes sidecar or metric collection agent like Telegraf, should be responsible for the collection and dispatch of those metrics. </p>
<p>Separating the collection and delivery of metrics from the recording allows the application to remain naïve and operate in many different environments without needing to change. The underlying dispatch of metrics can change live without impacting anything. The recording of metrics won&rsquo;t potentially have repercussions throughout the application if something fails; the collector can simply pick up and resume when it recovers.</p>
<h2 id="taking-full-advantage-of-time-series-data">Taking Full Advantage of Time Series Data</h2>
<p>An amazing way to create measurable metrics is to record state artifacts at a time interval. Viewing the various state details of an application over time&ndash;for example, sampling and recording the number of items in queue every second&ndash;can expose tons of insight into the behavior of the system.</p>
<p>Assuming you&rsquo;ve properly <a href="#abstracting-metric-collection-and-dispatch">abstracted your metric collection</a>, you should be able to trivially record details at a fairly quick interval without causing harm to the system. You want to be able to extrapolate meaning from the data both in realtime and historically simply by aggregating/partitioning the data differently. </p>
<p>Let&rsquo;s look at CPU utilization on a Windows workstation as an example. Viewing it realtime in Task Manager tells you how loaded the CPU is <em>right now</em> and what impacts to expect in the near term. Viewing it over the past 24 hours in Resource Monitor informs you on what your busiest hours are, which helps you plan your future days better. In both cases, the CPU usage is sampled at an interval and recorded; the only difference is the zoom level and aggregation of the samples.</p>
<h2 id="establishing-and-maintaining-slas-on-metrics">Establishing and Maintaining SLAs on Metrics</h2>
<p>The biggest goal of the monitoring effort, aside from system visibility, is the ability to define and assert success for a system. Being able to look meaningfully at the monitoring and alerts for a system and say, definitively, &ldquo;the system is operating successfully,&rdquo; has immeasurable value. It can:</p>
<ul>
<li>Increase confidence around the product/system</li>
<li>Reduce stress on the team and business</li>
<li>Quickly locate where problems actually lie and fix them directly</li>
<li>Alleviate conflation between different definitions of success</li>
</ul>
<table>
<thead>
<tr>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>To clarify the different definitions of success used here: a <em>product&rsquo;s</em> success can almost never be 100% determined by how well it satisifed its SLAs and how good its metrics look. A <em>system&rsquo;s</em> success can be shown much more mathematically.</td>
</tr>
</tbody>
</table>
<p>Defining success requires the creation of SLAs. The <a href="../../Misc/distributed-architecture-strategy/">Distributed Architecture Strategy</a> document goes into much greater detail about the creation and maintenance of SLAs. It is strongly recommended to read that entire document, but especially the section on SLAs and metrics. The SLAs you create for your system are not necessarily user-facing SLAs. Those are usually driven more by the business and sales pipelines, though they often strongly influence your internal SLAs. </p>
<p>SLAs can only be created and enforced around good metrics. Even the most basic SLA in the world, uptime percent, can&rsquo;t be upheld without metrics around service uptimes. Since raw uptime isn&rsquo;t really valuable&ndash;if one replica out of 100 is up, the service is technically still &ldquo;up&rdquo;&ndash;you need to define an <a href="../../Misc/distributed-architecture-strategy/#important-terms">uptime of scale</a> instead. Establishing an uptime of scale necessitates defining what <em>scale</em> means for your system. By the time you&rsquo;ve followed this thought process through, you&rsquo;ll have determined several metrics to record and items to monitor.</p>
<h2 id="alerting-meaningfully">Alerting Meaningfully</h2>
<p>Most systems alert too much. Developers and operators often err on the side of caution and choose fairly low thresholds to alert on, which leads to an overabundance of noisy alerts that may or may not actually represent a problem. Consumers begin to ignore the alerts, meaning that actual, valuable signals get lost in the ether. This isn&rsquo;t a theoretical problem; it&rsquo;s one that has proven itself historically. You&rsquo;ve seen it or heard of it: e-mail alerts getting automatically shuffled by Outlook rules into folders full of thousands and thousands of unread signals, most of which have less-than-zero value.</p>
<p>Make no mistake, however. Those alerts which really do have meaning are astoundingly valuable. This becomes especially true as the complexities of systems, architectures, and ecosystems increase. Being able to get meaningful signals from the various parts of a distributed application (or even a monolithic one) is vital to keeping systems healthy. In turn, this keeps the customers happy.</p>
<table>
<thead>
<tr>
<th><strong>Important</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>This section is primarily discussing infrastructure-, system-, and architecture-level alerts. As covered in the <a href="#system-level-alerts-vs-business-level-alerts">System-Level Alerts vs. Business-Level Alerts</a> sub-section, there is a strong distinction between alerts that are a <em>byproduct</em> of your application vs. those that are <em>part of</em> your application&rsquo;s business logic.</td>
</tr>
</tbody>
</table>
<h3 id="tips-for-alerting">Tips for Alerting</h3>
<p>Distinguishing what makes an alert a useful and meaningful signal can sometimes be tricky, but here are a few tips:</p>
<ul>
<li>An alert must be actionable. <ul>
<li>If you aren&rsquo;t sure whether something qualifies for alerting, ask someone else what they would <em>do</em> if they received the alert. </li>
<li>Since alerts should be actionable, if they can&rsquo;t tell you what they would do to address the alert, it might not be a valuable alert.</li>
</ul>
</li>
<li>As a rule of thumb, when a system has crossed into its <span style="color: #AAAA00;">yellow</span> or <span style="color: red;">red</span> states (see <a href="#dashboards-and-stoplights">Dashboards and Stoplights</a>), a signal should be raised.<ul>
<li>However, there must be a &ldquo;cooldown&rdquo; on this signal to prevent it from over-alerting when the system rapidly cycles between states.</li>
</ul>
</li>
<li>Alerts should usually be based on metrics.<ul>
<li>Specifically, a good signal is when an important metric is deviating significantly from its steady state.</li>
<li>Example: a queue-based message processing application has items in the queue, but its throughput is 0 over the most recent window of time. </li>
</ul>
</li>
<li>Alerts should contain the right information needed to convey the impact.<ul>
<li>In other words, you should strive to make the alert self-explanatory, without needing to dig in further to understand the problem. Some examples:</li>
<li><code>Spline reticulator reticulated 100 splines</code><ul>
<li>This is only a useful alert if you happen to know that 100 is <em>too many splines</em>.</li>
</ul>
</li>
<li><code>Spline reticulator reticulated 100 splines which exceeds the threshold of 25.</code><ul>
<li>This is better. It indicates:<ol>
<li>The reticulation exceeded a threshold, which is why there was an alert.</li>
<li>The magnitude of the excess was 100 vs. 25&ndash;a potential indicator of severity or urgency.</li>
</ol>
</li>
</ul>
</li>
<li><code>Spline reticulator reticulated 100 splines which exceeds the threshold of 25. This often indicates that the foo map is too complex or that the bar graph has too many baz nodes.</code><ul>
<li>This is even better. However, this much insight won&rsquo;t always be achievable or even desirable depending on the source of the alerts.</li>
</ul>
</li>
<li>Just as important as the metric information is some ability to correlate the alert to the system(s) it&rsquo;s based on. </li>
</ul>
</li>
<li>Ensure alerts are making it to the right people without that list going stale.<ul>
<li>An alert could be perfect, concise, and informative, but if it doesn&rsquo;t end up in the right places, it might as well not exist.</li>
<li>This often means making sure alerts are going to places abstracted from individual people. For example, alerting into a team-wide or division-wide Slack channel or emailing alerts to a distribution group that represents the concerned parties helps ensure that the right people see them no matter who may come and go within the company.</li>
</ul>
</li>
<li>Don&rsquo;t be afraid to lean on alerting frameworks for help.<ul>
<li>Getting the right quantity and quality from your alerts can be tough. These are solved problems; there&rsquo;s no reason to bang your head against the wall.</li>
<li>Grafana, for example, has a decent alerting rules engine built-in which is able to directly pull metrics from time-series databases like InfluxDB.</li>
</ul>
</li>
</ul>
<h3 id="application-logic-should-almost-never-alert">Application Logic Should (Almost) Never Alert</h3>
<p>Application logic should almost never create a system-level alert directly. Only in very rare scenarios should it even be able to do so. Your code should be handling errors gracefully (remember <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel&rsquo;s Law</a>), so the sort of explosions that you would need to signal should be infrastructural&ndash;things that the application platform would alert on instead. The responsibility of observing the system for critical states lies outside of your application, for the most part.</p>
<p>If an error is so severe that it cannot be handled, it&rsquo;s usually best to just crash. For the same reasons that your application should be recording metrics plainly, so too should it be failing plainly. The application platform and DevOps ecosystem must be robust enough to create the alerts around frequent application crashes&ndash;after all, you can&rsquo;t predict every reason your app might go down.</p>
<p>Let&rsquo;s look at a practical scenario. Pretend your application is a report runner; its purpose is to receive messages to run reports, run the reports, and write the output to a storage location. As an example, the app might crash if it hits a defined retry limit on trying to access its critical storage for the results. The application cannot continue when it&rsquo;s unable to write the results of its operations. In this example, crashing may even fix the error, depending on the application platform and storage medium. Transient errors or temporary mount disruptions can sometimes be corrected with an application restart.</p>
<p>That said, there are rare exceptions where your application may need to alert directly. Use your best judgement, given the guidance of this document and your team. Most of the time, if you feel like your application <em>must</em> alert, it&rsquo;s because the alerts fall into the category discussed in the next sub-section.</p>
<h3 id="system-level-alerts-vs-business-level-alerts">System-Level Alerts vs. Business-Level Alerts</h3>
<p>Most of the discussion in this section has been around metric-based, system-level alerting. Part of the reason your application shouldn&rsquo;t be doing its own alerting is the implication that it must therefore be concerning itself with consuming its own metrics and/or taking a dependency on an alerting mechanism. This goes against the guidance in the <a href="#abstracting-metric-collection-and-dispatch">Abstracting Metric Collection</a> section.</p>
<p>However, there is a type of alerting that doesn&rsquo;t fit the same mold: <em>business-level alerting</em>. Unlike the infrastructure-level signals this section has focused on so far, business-level alerts are driven by business rules and requirements. These alerts are not a byproduct of your application, <em>they <strong>are</strong> your application</em>. You must be very careful to distinguish these alert types, because they are very different use cases.</p>
<p>As an example, pretend your application is part of an ETL platform. Another application has extracted the data; yours is responsible for asserting the <em>completeness</em> of that data&ndash;as in, whether the source system provided all of the necessary data, based on a <em>business</em> definition of completeness. When your application sends an alert that the data is likely not complete, that alert is the output of your application. It is not the same kind of alerting as, say, signaling that the application is using 100% of its allocated RAM. The audience is different, the delivery mechanism is probably different, and the content is different. These are very likely two separate systems, serving two separate purposes.</p>
<p>Business-level alerts are fine, so long as they fall within the requirements and design of the application. Many of the same tips in this section could probably apply to them (e.g. they should be actionable, based on metrics, etc.) but there is much more room for flexibility here. Whatever is determined to provide value to the user is exactly how much alerting your application logic should do when it&rsquo;s business-level alerting.</p>
<h2 id="dashboards-and-stoplights">Dashboards and Stoplights</h2>
<table>
<thead>
<tr>
<th>Important</th>
</tr>
</thead>
<tbody>
<tr>
<td>Please read the <a href="../../Misc/distributed-architecture-strategy/#the-stoplight-strategy">Distributed Architecture Strategy section on Stoplights</a> before proceeding!</td>
</tr>
</tbody>
</table>
<p>During the design of any system, one of the first-class items should be a well-defined collection of dashboards designed to assist support and maintenance out of the gate. Using the dashboards, one should be able to answer many questions about the operation of the system and quickly, proactively diagnose issues. </p>
<p>Similarly, the collection of metrics and states that will define your steady state must be defined during the design effort. These <a href="https://en.wikipedia.org/wiki/Service-level_objective">SLO&rsquo;s</a> will help you define your stoplights.</p>
<ul>
<li>What conditions must be met for it to qualify as <span style="color: green;">green</span>?</li>
<li>What conditions cause it to be in a <span style="color: red;">red</span> state?</li>
<li>(For guidance to others) what does a <span style="color: #AAAA00;">yellow</span> state usually mean about the system?</li>
</ul>
<p>This at-a-glance discoverability has incalculable value, and cannot be anything less than a primary concern of every effort. It&rsquo;s far too easy to put dashboards and stoplights aside when the project is on a time crunch or trying to run with a thin crew, believing that the system will run fine without them. Perhaps it will, for a bit, but any production system that&rsquo;s intended to last will eventually go down. Every minute that system is down, it&rsquo;s costing you (either directly in revenue, or indirectly in damage to customer and stakeholder trust), and you&rsquo;ll wish you had all the tools available to correct the problem ASAP.</p>
<h1 id="logging">Logging</h1>
<p>Keeping clean, informative logs is one of the most important things developers can do to make a system more maintainable. However, it is perhaps one of the most challenging things to get &ldquo;right&rdquo;, second only to recording metrics. Too many logs (or too verbose) just leads to unreadable noise. Too few (or too sparse) and there are gaps in information and history that prevent issues from being traced. This section should help define a sweet spot of useful logs that become a reliable source of troubleshooting and auditing assistance.</p>
<h2 id="log-almost-everything">Log (Almost) Everything</h2>
<p>&hellip;</p>
<h2 id="minimize-application-logging-code">Minimize Application Logging Code</h2>
<p>&hellip;</p>
<h2 id="actionable-log-data">Actionable Log Data</h2>
<p>&hellip;</p>
<h2 id="meaningful-log-levels">Meaningful Log Levels</h2>
<p>Most logging libraries support a concept of log levels—such as <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warning</code>, and <code>error</code>; or sometimes represented as numbers—to help categorize and often thin out the amount of logs being written or consumed at a given time. Given that you should <a href="#log-almost-everything">log almost everything</a>, having a somewhat-standard way to denote the intention and importance of a log message is very useful. Otherwise, the number of logs can become overwhelming.</p>
<p>It is strongly recommended that you rely upon log levels in your logging implementation. However, unless the levels have well-established meaning, their intended use of reducing the amount of work one must do while spelunking through the logs is eliminated. </p>
<p>Here are a few guidelines for making log levels meaningful in your application:</p>
<ul>
<li>Make sure the log level of your application is configurable.<ul>
<li>Most of the time, the lowest levels of your logging are very verbose. The <code>trace</code> and <code>debug</code> levels, for example, often spit out several messages for every related <code>info</code> event.</li>
<li>That highly granular detail is not usually necessary for a system running in production. It&rsquo;s wise to make the log level configurable such that the verbose logs are not written unless the application is specially configured to output them.</li>
<li>Often, dev and QA environments will leave the verbose logging on. Production environments might turn it on occasionally if detailed troubleshooting is required.</li>
</ul>
</li>
<li>In the documentation, establish what types of events and messages should fall into which levels.<ul>
<li>The primary cause of meaningless log levels is when developers don&rsquo;t understand what each level should be used for, so information ends up poorly categorized.</li>
<li>As a default, use this:<ul>
<li><code>trace</code> is used for very fine-grained debugging information that often goes as deep as emitting a log when a method is called or even when specific lines of code are about to be executed. Obviously not every method or every line of code should log to the <code>trace</code> log, but important or impactful ones can be.<ul>
<li>Ex: <code>"parseJsonForMessage() called"</code></li>
</ul>
</li>
<li><code>debug</code> often represents critical state changes, important logical entry points or exit points, or data dumps that might be useful for debugging later.<ul>
<li>Ex: <code>"Begin parsing JSON for message 1234"</code></li>
</ul>
</li>
<li><code>info</code> is usually the lowest active logging level by default, and represents audit information, events and messages of interest, and other messages that help viewers understand standard process flow.<ul>
<li>Ex: <code>"Received message 1234"</code></li>
</ul>
</li>
<li><code>warning</code> is for events or messages that are slightly problematic or potentially concerning, but not immediately erroneous. However, as they often indicate future errors, they are quite important.</li>
<li><code>error</code> is straightforward: it denotes errors. An error may not necessarily be fatal (though it&rsquo;s very useful to make fatal ones obvious), but any time an erroneous state is encountered it should be logged. <ul>
<li>Non-fatal errors in user input/state and warnings often overlap in concern. It can be helpful to treat non-fatal user issues as warnings to help system-level errors stand out.</li>
<li>Ex: <code>"Message 1234 was larger than the maximium size of 1024 KB and could not be processed."</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Ensure that whatever method is used for digging through log files makes the log level visible and searchable—whether it&rsquo;s something as simple as flat text files or as complex as Splunk.<ul>
<li>For example, flat text logs should include the log level in the message so that advanced text editors like VS Code, Sublime Text, or Notepad++ can highlight and find it within the log.<ul>
<li>Ex: <code>2020-12-08T16:56:35.9319564-06:00 Info: Received message 1234</code></li>
<li>Ex: <code>2020-12-08T16:56:35.9319564-06:00 Error: Message 1234 was larger than the maximum size of 1024 KB and could not be processed."</code></li>
</ul>
</li>
</ul>
</li>
<li>Obviously, be consistent with how log levels are treated and what sorts of messages fall into which levels.</li>
</ul>
<h2 id="searchable-logs">Searchable Logs</h2>
<p>&hellip;</p>
<h2 id="logs-are-not-metrics-metrics-are-not-logs">Logs Are Not Metrics, Metrics Are Not Logs</h2>
<p>&hellip;</p>
<h1 id="patterns-and-practice">Patterns and Practice</h1>
<ul>
<li>Apply SOLID principles, but don&rsquo;t be dogmatic</li>
<li>Be monolithic when you need to be; be modular when it matters</li>
<li>Consume services responsibly; provide responsible services</li>
<li>Be creative where needed and formulaic to save time</li>
<li>YAGNI</li>
<li>Get WET before you worry about being DRY</li>
<li>Expose configuration externally to minimize the need for recompilation and redeployment</li>
<li>Avoid technical debt, and plan immediately to pay any you accrue off</li>
</ul>
<h1 id="infrastructure">Infrastructure</h1>
<ul>
<li>Express infrastructure requirements as code</li>
<li>Make your application highly available, load balanced, fault tolerant, and scalable</li>
<li>Consume resources responsibly</li>
<li>Store secrets securely</li>
<li>Have a back-out strategy for bad/failed deployments</li>
<li>Plan for emergency deployment of critical services—or document the lack of plan/capability</li>
</ul>
<h1 id="documentation-and-design">Documentation and Design</h1>
<ul>
<li>Create a design document that demonstrates how requirements will be satisfied</li>
<li>Address many of the same concerns as this document in your design doc</li>
<li>Record the intangibles for future reference to avoid tribal knowledge</li>
<li>Keep design, requirements, and other project docs centralized and grouped together</li>
<li>Treat API documentation as a first-class deliverable</li>
<li>Write self-documenting code </li>
<li>Automate doc creation and publishing</li>
</ul></div>
        </div>

        <footer class="col-md-12">
    <hr />
    <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>. <br/><small>Site last generated: 2022-07-07 15:34:55 (UTC)</small></p>

        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
